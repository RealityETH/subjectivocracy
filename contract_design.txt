* Non-forkonomic design *

-- L2 Ledger -----------------------

WETH Token
 - transfer
 - transferL1:
   - burn tokens, message L1:WETH wrapper to release X tokens for account Y
 - mintFor
   - receive message from WETH wrapper to mint X tokens for account Y

FooToken
 - transfer (internal to L2 ledger, doesn't exist on L1)

WeTrust
 - createCrowdFund
   - Call Reality.eth askQuestion
 - fundCrowdFund
 - settleCrowdFund
   - Call Reality.eth getFinalAnswer

Reality.eth
 - askQuestion
 - getFinalAnswer
 - requestArbitration

Reality.eth - Kleros adaptor

Kleros
 - createIssue
 - vote
 - resolveIssue


-- L1 ------------------------------

L2-Controller
 - L1ToL2Queue
 - L2ToL1Queue
 - ledger hash
 - various L2 challenge-related things

WETH Wrapper / bridge
 - lock ETH, message L2-Controller.L1ToL2Queue to mint X tokens for account Y on L2::WETH Token
 - read message from L2-Controller.L2ToL1Queue to release X tokens for account Y 




* Forkonomic design *

-- L2 Ledger -----------------------

WETH Token
 - transfer
 - transferL1:
   - burn tokens, message L1:WETH wrapper to release X tokens for account Y
 - mintFor
   - receive message from WETH wrapper to mint X tokens for account Y

FooToken
 - transfer (internal to L2 ledger, doesn't exist on L1)

WeTrust
 - createCrowdFund
   - Call Reality.eth askQuestion
 - fundCrowdFund
 - settleCrowdFund
   - Call Reality.eth getFinalAnswer

Reality.eth
 - askQuestion
 - getFinalAnswer
 - requestArbitration

Reality.eth - Kleros adaptor

Kleros
 - createIssue
 - vote
 - resolveIssue

WETHInsurer
 - stake goverance tokens
 - pays out ETH if !ForkManager::isInForkingState and L1:L2-Controller != ForkManager::l2controller, ie if there was a fork, and the one we're on didn't get the ETH
 - can create credit you with a token WInsuredETH

Reality.eth - ForkManager adaptor

-- L1 ------------------------------

L2-Controller
[ if there is a fork, there will be multiple of these, not just one ]
 - L1ToL2Queue
 - L2ToL1Queue
 - ledger hash
 - various L2 challenge-related things
 - forkManager


ForkManager is ERC20
 - l2controller
 - parentForkManager
 - forkingL2Controller1
 - forkingL2Controller2
 - isInForkingState()
 - requestFork(proposedL2Controller)
   - burns tokens
   - sets isInForkingState
   - clone L2-Controller? Or leave the current one as it is?
 - forkDeadline
 - resolve
   - sets winning forkingL2Controller to l2controller, turns off isInForkingState
 - currentBestForkManager() 
   - self unless forking completed
   - if forking completed, returns address of winner, recursively until we find a non-forked ForkManager


WETH Wrapper / bridge (traditional)
[ No awareness of forks, if there's a fork you have to withdraw then redeposit on the new fork ]
 - L2-Controller
 - lock ETH, message L2-Controller.L1ToL2Queue to mint X tokens for account Y on L2::WETH Token
 - read message from L2-Controller.L2ToL1Queue to release X tokens for account Y 

WETH Wrapper / bridge (fork-governed)
 Normally:
 - lock ETH, message L1ToL2Queue of ForkManager.currentBestForkManager().l2controller to mint X tokens for account Y on L2::WETH Token
 - read message from L2ToL1Queue of ForkManager.currentBestForkManager().l2controller to release X tokens for account Y 
 But if in forking state:
 - lock ETH, message L1ToL2Queue of ForkManager.currentBestForkManager()'s forkingL2Controller1 AND forkingL2Controller2 to mint X tokens for account Y on L2::WETH Token
 - read message from L2ToL1Queue of ForkManager.currentBestForkManager()'s forkingL2Controller1 AND forkingL2Controller2 release X tokens for account Y 


